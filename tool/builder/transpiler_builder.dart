import 'package:build/build.dart';
import 'package:analyzer/dart/analysis/utilities.dart';
import 'package:analyzer/dart/ast/ast.dart';
import 'package:analyzer/dart/ast/visitor.dart';
import 'package:source_gen/source_gen.dart';

// Builder factory function, defined in build.yaml
Builder shaderBuilder(BuilderOptions options) => ShaderBuilder();

class ShaderBuilder implements Builder {
  @override
  Map<String, List<String>> get buildExtensions => {
        '.dart': ['.g.dart']
      };

  @override
  Future<void> build(BuildStep buildStep) async {
    final resolver = buildStep.resolver;
    if (!await resolver.isLibrary(buildStep.inputId)) return;

    final lib = await buildStep.inputLibrary;
    final reader = LibraryReader(lib);

    final gpuSystems =
        reader.classes.where((c) => c.supertype?.element.name == 'GpuSystem');

    if (gpuSystems.isEmpty) return;

    final outputId = buildStep.inputId.changeExtension('.g.dart');
    String outputContent =
        "// Generated by the Nexus transpiler. DO NOT EDIT.\n";
    // Add the part of directive to link back to the source file.
    outputContent += "part of '${buildStep.inputId.pathSegments.last}';\n\n";

    for (final system in gpuSystems) {
      final source = await buildStep.readAsString(buildStep.inputId);
      final parsed = parseString(content: source, throwIfDiagnostics: false);
      final unit = parsed.unit;

      final targetFunction = unit.declarations
          .whereType<ClassDeclaration>()
          .firstWhere((c) => c.name.lexeme == system.name)
          .members
          .whereType<MethodDeclaration>()
          .firstWhere((m) => m.name.lexeme == 'gpuLogic');

      final visitor = WgslTranspilerVisitor();
      targetFunction.body.accept(visitor);

      final wgslCode = visitor.getWgslCode(system.name);

      // --- CRITICAL FIX: Correct variable naming convention ---
      // The correct syntax for a generated private variable is `_$variableName`.
      // The `\$` was incorrect and caused the compile error.
      // --- اصلاح حیاتی: قرارداد صحیح نام‌گذاری متغیر ---
      // سینتکس صحیح برای یک متغیر خصوصی تولید شده `_$variableName` است.
      // استفاده از `\$` اشتباه بود و باعث خطای کامپایل می‌شد.
      outputContent +=
          "const String _\$${system.name}Wgsl = r'''\n$wgslCode''';\n";
    }

    await buildStep.writeAsString(outputId, outputContent);
  }
}

// The AST Visitor logic remains the same.
class WgslTranspilerVisitor extends SimpleAstVisitor<void> {
  final StringBuffer _bodyWgsl = StringBuffer();

  @override
  void visitBlockFunctionBody(BlockFunctionBody node) {
    for (final statement in node.block.statements) {
      _bodyWgsl.writeln(_translateStatement(statement));
    }
  }

  String _translateStatement(Statement statement) {
    if (statement is ExpressionStatement) {
      return '    ${_translateExpression(statement.expression)};';
    }
    if (statement is IfStatement) {
      final condition = _translateExpression(statement.expression);
      final thenBlock = _translateStatement(statement.thenStatement);
      return '    if ($condition) {\n$thenBlock\n    }';
    }
    if (statement is Block) {
      return statement.statements.map(_translateStatement).join('\n');
    }
    if (statement is VariableDeclarationStatement) {
      final declaration = statement.variables.variables.first;
      final name = declaration.name.lexeme;
      final value = _translateExpression(declaration.initializer!);
      return '    var $name = $value;';
    }
    return '// Unsupported statement: ${statement.runtimeType}';
  }

  String _translateExpression(Expression expression) {
    if (expression is AssignmentExpression) {
      final left = _translateExpression(expression.leftHandSide);
      final right = _translateExpression(expression.rightHandSide);
      return '$left = $right';
    }
    if (expression is BinaryExpression) {
      final left = _translateExpression(expression.leftOperand);
      final right = _translateExpression(expression.rightOperand);
      final op = expression.operator.lexeme;
      // A real transpiler would need to handle operator precedence correctly.
      return '($left $op $right)';
    }
    if (expression is PrefixedIdentifier || expression is PropertyAccess) {
      return expression.toSource().replaceAll('final ', '');
    }
    if (expression is DoubleLiteral) {
      return expression.toSource();
    }
    if (expression is IntegerLiteral) {
      return '${expression.toSource()}.0';
    }
    if (expression is MethodInvocation) {
      // A real transpiler would map Dart math functions to WGSL built-ins
      return expression.toSource();
    }
    return '// Unsupported expression: ${expression.runtimeType}';
  }

  String getWgslCode(String systemName) {
    final header = '''
struct Particle {
    pos: vec2<f32>,
    vel: vec2<f32>,
    age: f32,
    max_age: f32,
    initial_size: f32,
    seed: f32,
};

struct SimParams {
    delta_time: f32,
    attractor_x: f32,
    attractor_y: f32,
    attractor_strength: f32,
};

@group(0) @binding(1)
var<uniform> params: SimParams;

@group(0) @binding(0)
var<storage, read_write> particles: array<Particle>;

fn hash(n: f32) -> f32 {
    return fract(sin(n) * 43758.5453123);
}
''';
    final mainFunction = '''
@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let index = global_id.x;
    if (index >= arrayLength(&particles)) { return; }
    var p = particles[index];

${_bodyWgsl.toString()}
    particles[index] = p;
}
''';
    return '$header\n$mainFunction';
  }
}
